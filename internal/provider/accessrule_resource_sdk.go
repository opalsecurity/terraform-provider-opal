// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/opalsecurity/terraform-provider-opal/v3/internal/provider/types"
	"github.com/opalsecurity/terraform-provider-opal/v3/internal/sdk/models/operations"
	"github.com/opalsecurity/terraform-provider-opal/v3/internal/sdk/models/shared"
)

func (r *AccessRuleResourceModel) RefreshFromSharedAccessRule(ctx context.Context, resp *shared.AccessRule) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.AdminOwnerID = types.StringValue(resp.AdminOwnerID)
		r.Description = types.StringValue(resp.Description)
		r.ID = types.StringValue(resp.ID)
		r.Name = types.StringValue(resp.Name)
		if resp.RuleClauses.Unless == nil {
			r.RuleClauses.Unless = nil
		} else {
			r.RuleClauses.Unless = &tfTypes.RuleConjunction{}
			r.RuleClauses.Unless.Clauses = []tfTypes.RuleDisjunction{}

			for _, clausesItem := range resp.RuleClauses.Unless.Clauses {
				var clauses tfTypes.RuleDisjunction

				clauses.Selectors = []tfTypes.TagSelector{}

				for _, selectorsItem := range clausesItem.Selectors {
					var selectors tfTypes.TagSelector

					selectors.ConnectionID = types.StringValue(selectorsItem.ConnectionID)
					selectors.Key = types.StringValue(selectorsItem.Key)
					selectors.Value = types.StringValue(selectorsItem.Value)

					clauses.Selectors = append(clauses.Selectors, selectors)
				}

				r.RuleClauses.Unless.Clauses = append(r.RuleClauses.Unless.Clauses, clauses)
			}
		}
		r.RuleClauses.When.Clauses = []tfTypes.RuleDisjunction{}

		for _, clausesItem1 := range resp.RuleClauses.When.Clauses {
			var clauses1 tfTypes.RuleDisjunction

			clauses1.Selectors = []tfTypes.TagSelector{}

			for _, selectorsItem1 := range clausesItem1.Selectors {
				var selectors1 tfTypes.TagSelector

				selectors1.ConnectionID = types.StringValue(selectorsItem1.ConnectionID)
				selectors1.Key = types.StringValue(selectorsItem1.Key)
				selectors1.Value = types.StringValue(selectorsItem1.Value)

				clauses1.Selectors = append(clauses1.Selectors, selectors1)
			}

			r.RuleClauses.When.Clauses = append(r.RuleClauses.When.Clauses, clauses1)
		}
		r.Status = types.StringValue(string(resp.Status))
	}

	return diags
}

func (r *AccessRuleResourceModel) ToOperationsDeleteGroupRequest(ctx context.Context) (*operations.DeleteGroupRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	out := operations.DeleteGroupRequest{
		ID: id,
	}

	return &out, diags
}

func (r *AccessRuleResourceModel) ToOperationsGetAccessRuleRequest(ctx context.Context) (*operations.GetAccessRuleRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	out := operations.GetAccessRuleRequest{
		ID: id,
	}

	return &out, diags
}

func (r *AccessRuleResourceModel) ToOperationsUpdateAccessRuleRequest(ctx context.Context) (*operations.UpdateAccessRuleRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	updateAccessRuleInfo, updateAccessRuleInfoDiags := r.ToSharedUpdateAccessRuleInfo(ctx)
	diags.Append(updateAccessRuleInfoDiags...)

	if diags.HasError() {
		return nil, diags
	}

	var id string
	id = r.ID.ValueString()

	out := operations.UpdateAccessRuleRequest{
		UpdateAccessRuleInfo: *updateAccessRuleInfo,
		ID:                   id,
	}

	return &out, diags
}

func (r *AccessRuleResourceModel) ToSharedUpdateAccessRuleInfo(ctx context.Context) (*shared.UpdateAccessRuleInfo, diag.Diagnostics) {
	var diags diag.Diagnostics

	var adminOwnerID string
	adminOwnerID = r.AdminOwnerID.ValueString()

	var description string
	description = r.Description.ValueString()

	var name string
	name = r.Name.ValueString()

	var unless *shared.RuleConjunction
	if r.RuleClauses.Unless != nil {
		clauses := make([]shared.RuleDisjunction, 0, len(r.RuleClauses.Unless.Clauses))
		for _, clausesItem := range r.RuleClauses.Unless.Clauses {
			selectors := make([]shared.TagSelector, 0, len(clausesItem.Selectors))
			for _, selectorsItem := range clausesItem.Selectors {
				var connectionID string
				connectionID = selectorsItem.ConnectionID.ValueString()

				var key string
				key = selectorsItem.Key.ValueString()

				var value string
				value = selectorsItem.Value.ValueString()

				selectors = append(selectors, shared.TagSelector{
					ConnectionID: connectionID,
					Key:          key,
					Value:        value,
				})
			}
			clauses = append(clauses, shared.RuleDisjunction{
				Selectors: selectors,
			})
		}
		unless = &shared.RuleConjunction{
			Clauses: clauses,
		}
	}
	clauses1 := make([]shared.RuleDisjunction, 0, len(r.RuleClauses.When.Clauses))
	for _, clausesItem1 := range r.RuleClauses.When.Clauses {
		selectors1 := make([]shared.TagSelector, 0, len(clausesItem1.Selectors))
		for _, selectorsItem1 := range clausesItem1.Selectors {
			var connectionId1 string
			connectionId1 = selectorsItem1.ConnectionID.ValueString()

			var key1 string
			key1 = selectorsItem1.Key.ValueString()

			var value1 string
			value1 = selectorsItem1.Value.ValueString()

			selectors1 = append(selectors1, shared.TagSelector{
				ConnectionID: connectionId1,
				Key:          key1,
				Value:        value1,
			})
		}
		clauses1 = append(clauses1, shared.RuleDisjunction{
			Selectors: selectors1,
		})
	}
	when := shared.RuleConjunction{
		Clauses: clauses1,
	}
	ruleClauses := shared.RuleClauses{
		Unless: unless,
		When:   when,
	}
	status := shared.UpdateAccessRuleInfoStatus(r.Status.ValueString())
	out := shared.UpdateAccessRuleInfo{
		AdminOwnerID: adminOwnerID,
		Description:  description,
		Name:         name,
		RuleClauses:  ruleClauses,
		Status:       status,
	}

	return &out, diags
}
