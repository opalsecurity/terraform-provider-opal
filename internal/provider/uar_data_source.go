// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	tfTypes "github.com/opalsecurity/terraform-provider-opal/internal/provider/types"
	"github.com/opalsecurity/terraform-provider-opal/internal/sdk"
	"github.com/opalsecurity/terraform-provider-opal/internal/sdk/models/operations"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &UarDataSource{}
var _ datasource.DataSourceWithConfigure = &UarDataSource{}

func NewUarDataSource() datasource.DataSource {
	return &UarDataSource{}
}

// UarDataSource is the data source implementation.
type UarDataSource struct {
	client *sdk.OpalAPI
}

// UarDataSourceModel describes the data model.
type UarDataSourceModel struct {
	Deadline                           types.String      `tfsdk:"deadline"`
	Name                               types.String      `tfsdk:"name"`
	ReviewerAssignmentPolicy           types.String      `tfsdk:"reviewer_assignment_policy"`
	SelfReviewAllowed                  types.Bool        `tfsdk:"self_review_allowed"`
	SendReviewerAssignmentNotification types.Bool        `tfsdk:"send_reviewer_assignment_notification"`
	TimeZone                           types.String      `tfsdk:"time_zone"`
	UarID                              types.String      `tfsdk:"uar_id"`
	UarScope                           *tfTypes.UARScope `tfsdk:"uar_scope"`
}

// Metadata returns the data source type name.
func (r *UarDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_uar"
}

// Schema defines the schema for the data source.
func (r *UarDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Uar DataSource",

		Attributes: map[string]schema.Attribute{
			"deadline": schema.StringAttribute{
				Computed:    true,
				Description: `The last day for reviewers to complete their access reviews.`,
			},
			"name": schema.StringAttribute{
				Computed:    true,
				Description: `The name of the UAR.`,
			},
			"reviewer_assignment_policy": schema.StringAttribute{
				Computed:    true,
				Description: `A policy for auto-assigning reviewers. If auto-assignment is on, specific assignments can still be manually adjusted after the access review is started. Default is Manually.`,
			},
			"self_review_allowed": schema.BoolAttribute{
				Computed:    true,
				Description: `A bool representing whether to present a warning when a user is the only reviewer for themself. Default is False.`,
			},
			"send_reviewer_assignment_notification": schema.BoolAttribute{
				Computed:    true,
				Description: `A bool representing whether to send a notification to reviewers when they're assigned a new review. Default is False.`,
			},
			"time_zone": schema.StringAttribute{
				Computed:    true,
				Description: `The time zone name (as defined by the IANA Time Zone database) used in the access review deadline and exported audit report. Default is America/Los_Angeles.`,
			},
			"uar_id": schema.StringAttribute{
				Required:    true,
				Description: `The ID of the UAR.`,
			},
			"uar_scope": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"admins": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `This access review will include resources and groups who are owned by one of the owners corresponding to the given IDs.`,
					},
					"apps": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `This access review will include items in the specified applications`,
					},
					"entities": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `This access review will include resources and groups with ids in the given strings.`,
					},
					"filter_operator": schema.StringAttribute{
						Computed:    true,
						Description: `Specifies whether entities must match all (AND) or any (OR) of the filters.`,
					},
					"group_types": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `This access review will include items of the specified group types`,
					},
					"group_visibility": schema.StringAttribute{
						Computed:    true,
						Description: `Specifies what users can see during an Access Review`,
					},
					"include_group_bindings": schema.BoolAttribute{
						Computed: true,
					},
					"names": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `This access review will include resources and groups whose name contains one of the given strings.`,
					},
					"resource_types": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `This access review will include items of the specified resource types`,
					},
					"tags": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:    true,
									Description: `The key of the tag.`,
								},
								"value": schema.StringAttribute{
									Computed:    true,
									Description: `The value of the tag.`,
								},
							},
						},
						Description: `This access review will include resources and groups who are tagged with one of the given tags.`,
					},
					"users": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `The access review will only include the following users. If any users are selected, any entity filters will be applied to only the entities that the selected users have access to.`,
					},
				},
				Description: `If set, the access review will only contain resources and groups that match at least one of the filters in scope.`,
			},
		},
	}
}

func (r *UarDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.OpalAPI)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected *sdk.OpalAPI, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *UarDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data *UarDataSourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Config.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var uarID string
	uarID = data.UarID.ValueString()

	request := operations.GetUARIDRequest{
		UarID: uarID,
	}
	res, err := r.client.Uars.GetID(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Uar != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedUar(ctx, res.Uar)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
